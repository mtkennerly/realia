// Inspired by:
// https://stackoverflow.com/a/41638455

mod args;
mod metadata;

use anyhow::{anyhow, Error};
use std::io::Write;
use structopt::StructOpt;

const CRATE_INFO_TEMPLATE: &str = r#"
pub struct CrateInfo<'a> {
    name: &'a str,
    version: &'a str,
    source: Option<&'a str>,
}
"#;

fn main() -> Result<(), Error> {
    let metadata = metadata::get(&args::Args::from_args())?;

    let active_package_name = std::env::var("CARGO_PKG_NAME").unwrap();
    let position = metadata
        .packages
        .iter()
        .position(|x| x.name == active_package_name)
        .ok_or_else(|| anyhow!("Cannot find metadata for current package"))?;
    let active_package = &metadata.packages[position];

    // If we're in the middle of `cargo publish`, we need to delete the lock
    // file that was generated by the metadata command, or else Cargo will
    // complain about modifying things outside of OUT_DIR.
    // If we can't remove, assume it doesn't exist.
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let bad_file = format!(
        "{}/target/package/{}-{}/Cargo.lock",
        manifest_dir,
        active_package_name,
        active_package.version.to_string()
    );
    let _ = std::fs::remove_file(bad_file);

    let mut packages = vec![(
        active_package.name.clone(),
        active_package.version.to_string(),
        match &active_package.source {
            Some(source) => Some(source.to_string()),
            None => None,
        },
    )];
    for dependency in &active_package.dependencies {
        let position = metadata
            .packages
            .iter()
            .position(|x| x.name == dependency.name)
            .unwrap();
        let package = &metadata.packages[position];
        let applicable = match &dependency.target {
            Some(target) => match target_spec::eval(&target.to_string(), &std::env::var("TARGET").unwrap()) {
                Ok(Some(true)) => true,
                _ => false,
            },
            _ => true,
        };
        if !applicable {
            continue;
        }
        packages.push((
            dependency.name.clone(),
            package.version.to_string(),
            dependency.source.clone(),
        ));
    }

    let out_dir = std::env::var("OUT_DIR").unwrap();
    let mut crates_file = std::fs::File::create(&std::path::Path::new(&out_dir).join("crate_info.rs")).unwrap();
    crates_file.write_all(CRATE_INFO_TEMPLATE.as_bytes()).unwrap();
    crates_file
        .write_all(format!("pub const CRATES: [CrateInfo; {}] = [", packages.len()).as_ref())
        .unwrap();
    for package in packages {
        crates_file
            .write_all(
                format!(
                    "CrateInfo {{ name: {:?}, version: {:?}, source: {:?} }},\n",
                    package.0, package.1, package.2
                )
                .as_ref(),
            )
            .unwrap();
    }
    crates_file.write_all("];".as_ref()).unwrap();

    Ok(())
}
